---
import Layout from '../../layouts/Layout.astro';
import ClassTable from '../../components/classes/ClassTable.astro';
import { classes } from '../../data/classes';
import { spells as allSpells } from '../../data/spells';

export function getStaticPaths() {
  return classes.map(classData => ({
    params: { id: classData.id },
    props: { classData }
  }));
}

const { classData } = Astro.props;

// Функция для преобразования текстовой таблицы в структурированные данные
function parseTableData(text: string) {
const rows = text.split('\n').filter(row => row.trim());
return rows.map(row => {
const [level, spells] = row.split('\t');
return { level, spells };
});
}
---

<Layout title={`${classData.name}`}>
  <div class="content">
    <a href="/classes" class="back-link">← Назад к классам</a>

    <div class="class-header">
      <h1>{classData.name} <span class="name-en">[{classData.nameEn}]</span></h1>
      <div class="source">{classData.sourceBook}</div>
    </div>

    <div class="class-description">
      <div class="subclass-selector">
        <select id="subclass-select">
          <option value="">Выберите подкласс</option>
          {classData.subclasses.map(subclass => (
            <option value={subclass.id}>{subclass.name} [{subclass.nameEn}]</option>
          ))}
        </select>
      </div>

      <div id="class-lore" class="lore-content">
        <p>{classData.description}</p>
      </div>

      <details id="base-lore" class="base-lore" style="display: none;">
        <summary>Основное описание класса</summary>
        <p>{classData.description}</p>
      </details>
    </div>

    <div class="class-basics">
      <div class="basic-info">
        <h2>Основные характеристики</h2>
        <dl>
          <dt>Основная характеристика</dt>
          <dd>{classData.primaryAbility}</dd>

          <dt>Кость хитов</dt>
          <dd>к{classData.hitDice}</dd>

          <dt>Хиты на 1 уровне</dt>
          <dd>{classData.hitPoints.level1}</dd>

          <dt>Хиты на следующих уровнях</dt>
          <dd>{classData.hitPoints.higherLevels}</dd>
        </dl>
      </div>

      {classData.multiclass && (
        <div class="multiclass-info">
          <h2>Мультикласс</h2>
          <div class="multiclass-description">
            <ul>
              {classData.multiclass.bullets.map(b => (
                <li>{b}</li>
              ))}
            </ul>
          </div>
        </div>
      )}

      <div class="proficiencies">
        <h2>Владения</h2>
        <dl>
          <dt>Доспехи</dt>
          <dd>{classData.proficiencies?.armor?.join(', ') || 'Нет'}</dd>

          <dt>Оружие</dt>
          <dd>{classData.proficiencies?.weapons?.join(', ') || 'Нет'}</dd>

          <dt>Спасброски</dt>
          <dd>{classData.proficiencies?.savingThrows?.join(', ') || 'Нет'}</dd>

          <dt>Навыки</dt>
          <dd>Выберите {classData.proficiencies.skills.count} из: {classData.proficiencies?.skills?.list?.join(', ') || 'Нет'}</dd>

          <dt>Инструменты</dt>
          <dd>{classData.proficiencies?.tools?.join(', ') || 'Нет'}</dd>
        </dl>
      </div>

      
    </div>

    <div class="equipment">
      <h2>Стартовое снаряжение</h2>
      <p>Выберите один из следующих наборов:</p>

      {classData.equipment.default.map(choice => (
        <div class="equipment-choice">
          <h3>Вариант {choice.choice}</h3>
          <ul>
            {choice.items.map(item => (
              <li set:html={item}></li>
            ))}
          </ul>
        </div>
      ))}
    </div>

    <div class="class-progression">
      <h2>Развитие класса</h2>
      <ClassTable levels={classData.levels} />
    </div>

    <div id="features-container" class="class-features">
      <h2>Умения класса</h2>
      {classData.features.map(feature => (
      <div class="feature">
        <div class="feature-header">
            <h3>{feature.name}</h3>
            <button type="button" class="copy-feature-btn" aria-label="Скопировать описание">Скопировать описание</button>
          <span class="feature-level">{feature.level} уровень</span>
        </div>
        <div class="feature-description">
            {feature.description.split('\n').map(paragraph => (
              <p>{paragraph}</p>
            ))}
          {feature.collapsible && (
            <div class="collapsible-content">
              {feature.collapsible.map(item => (
                <details class="collapsible-item">
                  <summary>{item.title}</summary>
                  <div class="collapsible-description">
                    {item.tableData ? (
                      <table class="spell-table">
                        <thead>
                          <tr>
                            {item.tableData.headers.map(header => (
                              <th>{header}</th>
                            ))}
                          </tr>
                        </thead>
                        <tbody>
                          {item.tableData.rows.map(row => (
                            <tr>
                              {row.map(cell => (
                                <td>{cell}</td>
                              ))}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    ) : (
                      item.description.split('\n').map(paragraph => (
                        <p>{paragraph}</p>
                      ))
                    )}
                  </div>
                </details>
              ))}
            </div>
          )}
        </div>
      </div>
      ))}
    </div>

    <!-- Template для создания элементов способностей -->
    <template id="feature-template">
      <div class="feature">
        <div class="feature-header">
          <h3></h3>
          <span class="feature-level"></span>
        </div>
        <div class="feature-description"></div>
      </div>
    </template>

    <!-- Scroll to top button -->
    <button id="scroll-to-top" class="scroll-to-top" aria-label="Прокрутить наверх">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="m18 15-6-6-6 6"/>
      </svg>
    </button>
  </div>
</Layout>

<script type="module" define:vars={{ classData, allSpells }}>

  document.addEventListener('DOMContentLoaded', () => {
    const subclassSelect = document.getElementById('subclass-select');
    const classLore = document.getElementById('class-lore');
    const baseLore = document.getElementById('base-lore');
    const featuresContainer = document.getElementById('features-container');
    const featureTemplate = document.getElementById('feature-template');
    let currentSubclass = null;

    // Create tooltip element and initialize inline tooltip handlers
    const tooltipEl = document.createElement('div');
    tooltipEl.id = 'spell-tooltip';
    tooltipEl.style.display = 'none';
    tooltipEl.style.position = 'fixed';
    tooltipEl.style.zIndex = '10000';
    document.body.appendChild(tooltipEl);

    const tooltipConfig = { offsetX: 12, offsetY: 12, fadeInDelay: 220, fadeOutDelay: 120 };
    let tooltipShowTimeout = null;
    let tooltipHideTimeout = null;
    let currentSpellLink = null;
    let isHoveringTooltip = false;

    tooltipEl.addEventListener('mouseenter', () => {
      isHoveringTooltip = true;
      if (tooltipHideTimeout) {
        clearTimeout(tooltipHideTimeout);
        tooltipHideTimeout = null;
      }
    });

    tooltipEl.addEventListener('mouseleave', () => {
      isHoveringTooltip = false;
      scheduleHide();
    });

    document.addEventListener('mouseover', (e) => {
      const target = e.target;
      const link = target.closest ? target.closest('.spell-link') : null;

      if (link && link.dataset.spellId) {
        if (tooltipHideTimeout) {
          clearTimeout(tooltipHideTimeout);
          tooltipHideTimeout = null;
        }

        currentSpellLink = link;
        const spellId = link.dataset.spellId;

        tooltipShowTimeout = setTimeout(() => {
          const spell = allSpells.find(s => s.id === spellId);
          if (spell) {
            showTooltip(spell, e);
          }
        }, tooltipConfig.fadeInDelay);
      }
    });

    document.addEventListener('mouseout', (e) => {
      const target = e.target;
      const link = target.closest ? target.closest('.spell-link') : null;

      if (link) {
        if (tooltipShowTimeout) {
          clearTimeout(tooltipShowTimeout);
          tooltipShowTimeout = null;
        }

        const relatedTarget = e.relatedTarget;
        if (relatedTarget && (relatedTarget === tooltipEl || tooltipEl.contains(relatedTarget))) {
          return;
        }

        scheduleHide();
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (!tooltipEl || tooltipEl.style.display === 'none') return;
      const target = e.target;
      const link = target.closest ? target.closest('.spell-link') : null;
      if (link === currentSpellLink) {
        positionTooltip(e);
      }
    });

    function scheduleHide() {
      tooltipHideTimeout = setTimeout(() => {
        if (!isHoveringTooltip) hideTooltip();
      }, tooltipConfig.fadeOutDelay);
    }

    function showTooltip(spell, event) {
      tooltipEl.innerHTML = renderTooltipContent(spell);
      tooltipEl.style.display = 'block';
      tooltipEl.setAttribute('aria-hidden', 'false');
      positionTooltip(event);
    }

    function hideTooltip() {
      tooltipEl.style.display = 'none';
      tooltipEl.setAttribute('aria-hidden', 'true');
      tooltipEl.innerHTML = '';
      currentSpellLink = null;
    }

    function positionTooltip(event) {
      const rect = tooltipEl.getBoundingClientRect();
      const vpW = window.innerWidth;
      const vpH = window.innerHeight;

      let left = event.clientX + tooltipConfig.offsetX;
      let top = event.clientY + tooltipConfig.offsetY;

      // If the cursor is on the right side of the viewport, prefer showing
      // the tooltip to the left of the cursor so it doesn't cover the link.
      if (event.clientX > vpW * 0.66) {
        left = event.clientX - rect.width - tooltipConfig.offsetX;
      }

      if (left + rect.width + 12 > vpW) {
        left = vpW - rect.width - 12;
      }

      if (top + rect.height + 12 > vpH) {
        top = Math.max(12, vpH - rect.height - 12);
      }

      left = Math.max(8, left);
      top = Math.max(8, top);

      // Avoid covering the hovered link if possible
      try {
        if (currentSpellLink && currentSpellLink.getBoundingClientRect) {
          const linkRect = currentSpellLink.getBoundingClientRect();
          const wouldOverlap = !(left + rect.width < linkRect.left || left > linkRect.right || top + rect.height < linkRect.top || top > linkRect.bottom);
          if (wouldOverlap) {
            // Move tooltip to the left of the link if there's space
            const altLeft = linkRect.left - rect.width - 8;
            if (altLeft > 8) left = altLeft;
            else {
              // otherwise try moving above the link
              const altTop = linkRect.top - rect.height - 8;
              if (altTop > 8) top = altTop;
            }
          }
        }
      } catch (e) {
        // ignore
      }

      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
    }

    function renderTooltipContent(spell) {
      const levelText = spell.level === 'cantrip' ? 'Заговор' : `${spell.level} уровень`;
      const components = formatComponents(spell.components || {});

      return `
        <div class="tooltip-card">
          <div class="tooltip-header">
            <div class="tooltip-title">${spell.name} <span class="name-en">[${spell.nameEn}]</span></div>
            <div class="tooltip-source">${(spell.source && spell.source.book) || ''}${spell.source && spell.source.page ? ', стр. ' + spell.source.page : ''}</div>
          </div>
          <div class="tooltip-meta">
            <span class="tooltip-level">${levelText}</span>
            <span class="tooltip-school">${spell.school || ''}</span>
          </div>
          <div class="tooltip-attrs">
            <div><strong>Время:</strong> ${spell.castingTime || ''}</div>
            <div><strong>Дистанция:</strong> ${spell.range || ''}</div>
            <div><strong>Компоненты:</strong> ${components}</div>
            <div><strong>Длительность:</strong> ${spell.duration || ''}</div>
          </div>
          <div class="tooltip-desc">${spell.description || ''}</div>
        </div>
      `;
    }

    function formatComponents(components) {
      const parts = [];
      if (components.verbal) parts.push('В');
      if (components.somatic) parts.push('С');
      if (components.material) parts.push(`М (${components.material})`);
      return parts.join(', ');
    }

    // Linkify server-rendered feature content (but NOT the top-level class
    // description). Markers in features should become links and get tooltip hooks.
    try {
      linkifySpellsInNode(featuresContainer, allSpells);
    } catch (e) {
      console.error('initial linkify failed', e);
    }

    // Replace plain text occurrences inside text nodes with anchor links to spells
    // Replace the first occurrence of `name` inside `textNode` with an anchor.
    // Returns the "after" text node so callers can continue processing the rest
    // of the original text (allows multiple replacements inside the same node).
    function replaceTextNodeWithLink(textNode, name, id) {
      const idx = textNode.nodeValue.indexOf(name);
      if (idx === -1) return null;

      const parent = textNode.parentNode;
      if (!parent) return null;

      const beforeText = textNode.nodeValue.slice(0, idx);
      const afterText = textNode.nodeValue.slice(idx + name.length);

      const before = document.createTextNode(beforeText);
      const link = document.createElement('a');
      link.href = `/spells/${encodeURIComponent(id)}`;
      link.className = 'spell-link';
      link.dataset.spellId = id;
      link.textContent = name;
      const after = document.createTextNode(afterText);

      parent.insertBefore(before, textNode);
      parent.insertBefore(link, textNode);
      parent.insertBefore(after, textNode);
      parent.removeChild(textNode);

      return after;
    }

    function linkifySpellsInNode(container, spellsList) {
      if (!container) return;

      // First, add class/dataset to existing anchors with /spells/ in href
      const anchors = container.querySelectorAll('a[href*="/spells/"]');
      anchors.forEach(a => {
        if (!a.classList.contains('spell-link')) {
          const href = a.getAttribute('href') || '';
          const m = href.match(/\/spells\/(.+?)(?:[\/\?#]|$)/);
          if (m) {
            a.classList.add('spell-link');
            a.dataset.spellId = decodeURIComponent(m[1]);
          }
        }
      });

      // Then walk text nodes and replace exact spell name occurrences with anchors
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
      const textNodes = [];
      let node;
      while (node = walker.nextNode()) { // eslint-disable-line no-cond-assign
        textNodes.push(node);
      }

      const markerRe = /\[spell:([^\]|]+)(?:\|([^\]]+))?\]/;
      for (const tNode of textNodes) {
        // skip whitespace-only
        if (!tNode.nodeValue || !tNode.nodeValue.trim()) continue;
        // don't touch if parent is an anchor
        if (tNode.parentElement && tNode.parentElement.closest('a')) continue;
        // First handle explicit markers like [spell:speak-with-animals|Label]
        const m = tNode.nodeValue.match(markerRe);
        if (m) {
          const id = m[1];
          const label = m[2] || (spellsList.find(s => s.id === id)?.name || id);
          const replacedNode = replaceTextNodeWithLink(tNode, m[0], id);
          if (replacedNode) {
            const anchors = container.querySelectorAll(`a.spell-link[data-spell-id="${id}"]`);
            if (anchors.length) anchors[anchors.length - 1].textContent = label;
            // continue processing the remainder of this original node (after the marker)
            let cursor = replacedNode;
            // try to find additional markers in the remainder
            while (cursor && cursor.nodeValue && markerRe.test(cursor.nodeValue)) {
              const mm = cursor.nodeValue.match(markerRe);
              if (!mm) break;
              const id2 = mm[1];
              const label2 = mm[2] || (spellsList.find(s => s.id === id2)?.name || id2);
              const nextAfter = replaceTextNodeWithLink(cursor, mm[0], id2);
              if (nextAfter) {
                const a2 = container.querySelectorAll(`a.spell-link[data-spell-id="${id2}"]`);
                if (a2.length) a2[a2.length - 1].textContent = label2;
                cursor = nextAfter;
                continue;
              }
              break;
            }
            continue;
          }
        }

        // For plain-name matching we apply a light-weight context heuristic to
        // reduce false positives: only auto-link when the node looks like a
        // comma-separated list or contains recommendation words (e.g. "Рекомендуются").
        const nodeText = tNode.nodeValue;
        const lowerText = nodeText.toLowerCase();
        // Detect lists: comma-separated, recommendation phrases, or simple
        // conjunction lists using 'и' (e.g. "A и B" or "A, B и C"). We look
        // for capitalized words around 'и' to reduce false positives in prose.
        const hasComma = nodeText.includes(',');
        const hasRecommend = /рекоменду/i.test(lowerText);
        const hasConjunctionList = /[A-ZА-ЯЁ][^\n]{0,40}\s+и\s+[A-ZА-ЯЁ]/.test(nodeText);
        const hasKnowPhrase = /вы знаете/i.test(lowerText);
        // If the text node is inside a table, treat it as list-like (tables often contain spell lists)
        let isInTable = false;
        let hasLevelHeader = false;
        try {
          const tbl = tNode.parentElement && tNode.parentElement.closest ? tNode.parentElement.closest('table') : null;
          if (tbl) {
            isInTable = true;
            const ths = Array.from(tbl.querySelectorAll('th'));
            hasLevelHeader = ths.some(th => /Уровень\s*\d+/i.test((th.textContent||'').trim()));
          }
        } catch (e) {
          // ignore DOM errors
        }

        const looksLikeList = hasComma || hasRecommend || hasConjunctionList || hasKnowPhrase || isInTable || hasLevelHeader;

        if (!looksLikeList) continue;

        // Collect candidate spells that appear in the node's text.
        const candidates = spellsList.filter(s => nodeText.indexOf(s.name) !== -1);
        if (candidates.length === 0) continue;

        // For reliable multi-replacement, find all non-overlapping occurrences
        // of candidate names in the node, left-to-right, and rebuild the node
        // content with links inserted.
        const matches = [];
        for (const cand of candidates) {
          let start = 0;
          while (true) {
            const idx = nodeText.indexOf(cand.name, start);
            if (idx === -1) break;
            // boundary checks (not part of larger word)
            const leftChar = idx > 0 ? nodeText[idx - 1] : '';
            const rightChar = idx + cand.name.length < nodeText.length ? nodeText[idx + cand.name.length] : '';
            const leftOk = leftChar === '' || /[\s\(\[\.,;:\-–—]/.test(leftChar);
            const rightOk = rightChar === '' || /[\s\)\]\.,;:\-–—]/.test(rightChar);
            if (leftOk && rightOk) {
              matches.push({ index: idx, name: cand.name, id: cand.id, length: cand.name.length });
            }
            start = idx + cand.name.length;
          }
        }

        if (matches.length === 0) continue;

          // Prefer longer spell names when overlaps occur (e.g. "Дружба" vs "Дружба с животными").
          // Select non-overlapping matches by accepting longer matches first,
          // then sort chosen matches by index for assembly.
          matches.sort((a, b) => {
            if (b.length !== a.length) return b.length - a.length; // longer first
            return a.index - b.index;
          });
          const occupied = new Array(nodeText.length).fill(false);
          const chosen = [];
          for (const m2 of matches) {
            let conflict = false;
            for (let p = m2.index; p < m2.index + m2.length; p++) {
              if (occupied[p]) { conflict = true; break; }
            }
            if (!conflict) {
              chosen.push(m2);
              for (let p = m2.index; p < m2.index + m2.length; p++) occupied[p] = true;
            }
          }
          // sort chosen by index ascending for correct reconstruction
          chosen.sort((a, b) => a.index - b.index);

        // Rebuild node content
        const parent = tNode.parentNode;
        if (!parent) continue;
        let pos = 0;
        const frag = document.createDocumentFragment();
        for (const m of chosen) {
          if (m.index > pos) {
            frag.appendChild(document.createTextNode(nodeText.slice(pos, m.index)));
          }
          const a = document.createElement('a');
          a.href = `/spells/${encodeURIComponent(m.id)}`;
          a.className = 'spell-link';
          a.dataset.spellId = m.id;
          a.textContent = m.name;
          frag.appendChild(a);
          pos = m.index + m.length;
        }
        if (pos < nodeText.length) frag.appendChild(document.createTextNode(nodeText.slice(pos)));
        parent.insertBefore(frag, tNode);
        parent.removeChild(tNode);
      }
    }

    function createTableElement(tableText) {
      const rows = tableText.split('\n').filter(row => row.trim());
      const table = document.createElement('table');
      table.className = 'spell-table';

      // Check if this is a header-data table format
      const hasHeaders = rows.length > 1 && (
        rows[0].includes('\t') || 
        rows[0].split(/\s{2,}/).length > 1
      );

      if (hasHeaders) {
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        const headers = rows[0].includes('\t') 
          ? rows[0].split('\t') 
          : rows[0].split(/\s{2,}/);
        
        headers.forEach(header => {
          const th = document.createElement('th');
          th.textContent = header.trim();
          headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');
        rows.slice(1).forEach(row => {
          const tr = document.createElement('tr');
          const cells = row.includes('\t') 
            ? row.split('\t') 
            : row.split(/\s{2,}/);
          
          cells.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell.trim();
            tr.appendChild(td);
          });
          
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      } else {
        // Fallback for simple row-based tables
        const tbody = document.createElement('tbody');
        rows.forEach(row => {
          const tr = document.createElement('tr');
          const cells = row.includes('\t') 
            ? row.split('\t') 
            : row.split(/\s{2,}/);
          
          cells.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell.trim();
            tr.appendChild(td);
          });
          
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      }

      return table;
    }

    function createFeatureElement(feature, isSubclassFeature = false) {
      const template = featureTemplate.content.cloneNode(true);
      const featureElement = template.querySelector('.feature');
      
      if (isSubclassFeature) {
        featureElement.classList.add('subclass-feature');
      }
      
      featureElement.querySelector('h3').textContent = feature.name;
      // Inject copy button for dynamically created features so subclass features
      // also get the copy control just like server-rendered ones.
      const headerEl = featureElement.querySelector('.feature-header');
      const levelEl = headerEl.querySelector('.feature-level');
      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'copy-feature-btn';
      copyBtn.setAttribute('aria-label', 'Скопировать описание');
      copyBtn.textContent = 'Скопировать описание';
      // Ensure dynamically created button has expected visual styling
      copyBtn.style.background = 'var(--background)';
      copyBtn.style.border = '1px solid var(--card-border)';
      copyBtn.style.color = 'var(--text)';
      copyBtn.style.padding = '0.25rem 0.5rem';
      copyBtn.style.borderRadius = '0.25rem';
      copyBtn.style.cursor = 'pointer';
      copyBtn.style.fontSize = '0.875rem';
      copyBtn.style.lineHeight = '1';
      copyBtn.style.marginRight = '2rem';
      headerEl.insertBefore(copyBtn, levelEl);
      featureElement.querySelector('.feature-level').textContent = `${feature.level} уровень`;
      
      const descriptionContainer = featureElement.querySelector('.feature-description');
      
      if (feature.collapsible) {
        // Render any textual description first (server renders this too)
        if (feature.description) {
          feature.description.split('\n').forEach(paragraph => {
            const p = document.createElement('p');
            p.textContent = paragraph;
            descriptionContainer.appendChild(p);
          });
        }

        const collapsibleContent = document.createElement('div');
        collapsibleContent.className = 'collapsible-content';

        feature.collapsible.forEach(item => {
          const details = document.createElement('details');
          details.className = 'collapsible-item';
          
          const summary = document.createElement('summary');
          summary.textContent = item.title;
          details.appendChild(summary);
          
          const description = document.createElement('div');
          description.className = 'collapsible-description';
          
          if (item.tableData) {
            // Create table from structured data
            const table = document.createElement('table');
            table.className = 'spell-table';
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            item.tableData.headers.forEach(header => {
              const th = document.createElement('th');
              th.textContent = header;
              headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body
            const tbody = document.createElement('tbody');
            item.tableData.rows.forEach(row => {
              const tr = document.createElement('tr');
              row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            
            description.appendChild(table);
          } else {
            // Regular text content
            item.description.split('\n').forEach(paragraph => {
              const p = document.createElement('p');
              p.textContent = paragraph;
              description.appendChild(p);
            });
          }
          
          details.appendChild(description);
          collapsibleContent.appendChild(details);
        });
        
        descriptionContainer.appendChild(collapsibleContent);
      } else if (feature.name.toLowerCase().includes('таблица')) {
        const table = createTableElement(feature.description);
        descriptionContainer.appendChild(table);
      } else {
        feature.description.split('\n').forEach(paragraph => {
          const p = document.createElement('p');
          p.textContent = paragraph;
          descriptionContainer.appendChild(p);
            // After building description, linkify spell anchors and plain names safely
            try {
              linkifySpellsInNode(descriptionContainer, allSpells);
            } catch (e) {
              // non-fatal
              console.error('linkify error', e);
            }
        });
      }

      return featureElement;
    }

    function updateFeatures(subclassId) {
      if (!featuresContainer || !featureTemplate) return;

      let features = [...classData.features];
      if (subclassId) {
        const subclass = classData.subclasses.find(s => s.id === subclassId);
        if (subclass) {
          // Get all levels where subclass has features
          const subclassLevels = new Set(subclass.features.map(f => f.level));
          
          // Filter out base class features that are replaced by subclass features
          features = features.filter(f => {
            // Keep feature if level doesn't have subclass features
            if (!subclassLevels.has(f.level)) return true;
            
            // Remove the subclass selection feature
            if (f.name.includes('Подкласс') || f.name.includes('Круг') || 
                f.name.includes('Домен') || f.name.includes('Путь')) {
              return false;
            }
            
            return true;
          });
          
          // Add subclass features
          features = [...features, ...subclass.features];
        }
      }

      features.sort((a, b) => a.level - b.level);

      const title = featuresContainer.querySelector('h2');
      featuresContainer.innerHTML = '';
      featuresContainer.appendChild(title);

      features.forEach(feature => {
        const isSubclassFeature = subclassId && classData.subclasses
          .find(s => s.id === subclassId)?.features
          .some(f => f.name === feature.name);
        const featureElement = createFeatureElement(feature, isSubclassFeature);
        featuresContainer.appendChild(featureElement);
      });
      // Ensure spell links and tooltip hooks are set after rendering
      try {
        linkifySpellsInNode(featuresContainer, allSpells);
        try {
          const inst = window.__itemTooltipInstance;
          if (inst && typeof inst.annotateItemAnchors === 'function') {
            inst.annotateItemAnchors(featuresContainer);
          }
        } catch (err) {
          // non-fatal
        }
      } catch (e) {
        console.error('linkify after updateFeatures failed', e);
      }
    }

    subclassSelect?.addEventListener('change', (e) => {
      const subclassId = e.target.value;
      const subclass = classData.subclasses.find(s => s.id === subclassId);
      
      // Save subclass selection to localStorage
      if (subclassId) {
        localStorage.setItem(`class-${classData.id}-subclass`, subclassId);
      } else {
        localStorage.removeItem(`class-${classData.id}-subclass`);
      }

      // Update URL with subclass selection
      const newUrl = subclassId 
        ? `/classes/${classData.id}?subclass=${subclassId}`
        : `/classes/${classData.id}`;
      window.history.pushState({ subclassId }, '', newUrl);
      if (classLore && baseLore) {
        if (subclass) {
          classLore.innerHTML = subclass.description.split('\n').map(paragraph =>
            `<p>${paragraph}</p>`
          ).join('');
          baseLore.style.display = 'block';
        } else {
          classLore.innerHTML = classData.description.split('\n').map(paragraph =>
            `<p>${paragraph}</p>`
          ).join('');
          baseLore.style.display = 'none';
        }
      }

      updateFeatures(subclassId);
    });
    
    // Load saved subclass selection on page load
    function loadSavedSubclass() {
      // Check URL parameters first, then localStorage
      const urlParams = new URLSearchParams(window.location.search);
      const urlSubclass = urlParams.get('subclass');
      const savedSubclass = urlSubclass || localStorage.getItem(`class-${classData.id}-subclass`);
      
      if (savedSubclass && subclassSelect) {
        subclassSelect.value = savedSubclass;
        // Trigger change event to update the display
        subclassSelect.dispatchEvent(new Event('change'));
      }
    }
    
    // Handle browser back/forward buttons
    window.addEventListener('popstate', (event) => {
      const urlParams = new URLSearchParams(window.location.search);
      const subclassId = urlParams.get('subclass') || '';
      
      if (subclassSelect) {
        subclassSelect.value = subclassId;
        // Trigger change event to update the display
        subclassSelect.dispatchEvent(new Event('change'));
      }
    });
    
    // Save scroll position periodically and on page unload
    function saveScrollPosition() {
      localStorage.setItem(`class-${classData.id}-scroll`, window.scrollY.toString());
    }
    
    // Load saved scroll position
    function loadScrollPosition() {
      const savedScroll = localStorage.getItem(`class-${classData.id}-scroll`);
      if (savedScroll) {
        // Use setTimeout to ensure DOM is fully rendered
        setTimeout(() => {
          window.scrollTo(0, parseInt(savedScroll));
        }, 100);
      }
    }
    
    // Save scroll position on scroll (throttled)
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(saveScrollPosition, 150);
    });
    
    // Save scroll position before page unload
    window.addEventListener('beforeunload', saveScrollPosition);
    
    // Initialize saved states
    loadSavedSubclass();
    loadScrollPosition();
    
    // Scroll to top button functionality
    const scrollToTopButton = document.getElementById('scroll-to-top');
    
    function toggleScrollButton() {
      if (scrollToTopButton) {
        if (window.scrollY > 300) {
          scrollToTopButton.classList.add('visible');
        } else {
          scrollToTopButton.classList.remove('visible');
        }
      }
    }
    
    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    
    // Show/hide button based on scroll position
    window.addEventListener('scroll', toggleScrollButton);
    
    // Scroll to top when button is clicked
    scrollToTopButton?.addEventListener('click', scrollToTop);
    
    // Initial check for button visibility
    toggleScrollButton();

    // Initialize shared item tooltip using utility (load script and use window.ItemTooltip)
    (function ensureItemTooltipAndInit(){
      function ensureItemTooltip(){
        return new Promise((resolve,reject)=>{
          if (window.ItemTooltip) return resolve(window.ItemTooltip);
          if (document.querySelector('script[data-item-tooltip]')){
            const check = setInterval(()=>{ if (window.ItemTooltip){ clearInterval(check); resolve(window.ItemTooltip); } },50);
            setTimeout(()=>{ clearInterval(check); reject(new Error('timeout loading itemTooltip')); },5000);
            return;
          }
          const s = document.createElement('script');
          s.src = '/js/itemTooltip.js';
          s.async = true;
          s.setAttribute('data-item-tooltip','1');
          s.onload = ()=> resolve(window.ItemTooltip);
          s.onerror = (e)=> reject(e);
          document.head.appendChild(s);
        });
      }

      // Will hold initialized instance so other code can call annotateItemAnchors
      let _itemTooltipInstance = null;

      ensureItemTooltip().then(ItemTooltip => {
        try {
          const itemTooltipEl = document.createElement('div');
          itemTooltipEl.id = 'item-tooltip';
          itemTooltipEl.style.display = 'none';
          itemTooltipEl.style.position = 'fixed';
          itemTooltipEl.style.zIndex = '10000';
          document.body.appendChild(itemTooltipEl);

          const ItemCtor = ItemTooltip;
          const itemTooltip = new ItemCtor({
            offsetX: tooltipConfig.offsetX,
            offsetY: tooltipConfig.offsetY,
            fadeInDelay: tooltipConfig.fadeInDelay,
            fadeOutDelay: tooltipConfig.fadeOutDelay
          });
          itemTooltip.init(itemTooltipEl);
          _itemTooltipInstance = itemTooltip;
          // expose for other scripts/tests
          window.__itemTooltipInstance = itemTooltip;

          // Annotate any existing content (featuresContainer may contain item links)
          try {
            if (typeof itemTooltip.annotateItemAnchors === 'function') {
              itemTooltip.annotateItemAnchors(document.body);
            }
          } catch (e) {
            console.warn('annotateItemAnchors failed', e);
          }
        } catch (e) {
          console.error('item tooltip init failed', e);
        }
      }).catch(err => console.error('failed loading itemTooltip script', err));
    })();
  });
</script>

<script type="module" define:vars={{ classData }}>
  // Copy feature description handler (delegated)
  document.addEventListener('click', (e) => {
    const btn = e.target.closest ? e.target.closest('.copy-feature-btn') : null;
    if (!btn) return;

    const featureEl = btn.closest('.feature');
    if (!featureEl) return;

    const name = (featureEl.querySelector('h3')?.innerText || '').trim();
    const levelText = (featureEl.querySelector('.feature-level')?.innerText || '').trim();
    const desc = (featureEl.querySelector('.feature-description')?.innerText || '').trim();
    const className = (classData && classData.name) ? classData.name : '';

    const textToCopy = `${name}\n${className} ${levelText}\n${desc}`;

    // Show a small tooltip above the button when copied.
    const restoreLabel = () => { /* no-op: we keep button label */ };

    const showCopyTooltip = (btnEl) => {
      let tip = document.querySelector('.copy-tooltip');
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'copy-tooltip';
        tip.setAttribute('role', 'status');
        tip.setAttribute('aria-live', 'polite');
        document.body.appendChild(tip);
      }
      tip.textContent = 'Скопировано!';
      tip.style.opacity = '0';
      tip.style.display = 'block';

      // position above button
      const btnRect = btnEl.getBoundingClientRect();
      // allow render to compute size
      requestAnimationFrame(() => {
        const tipRect = tip.getBoundingClientRect();
        let left = btnRect.left + (btnRect.width / 2) - (tipRect.width / 2);
        let top = btnRect.top - tipRect.height - 8;
        // if not enough space above, show below
        if (top < 8) top = btnRect.bottom + 8;
        // clamp horizontally
        left = Math.max(8, Math.min(left, window.innerWidth - tipRect.width - 8));
        tip.style.left = left + 'px';
        tip.style.top = top + 'px';
        tip.style.opacity = '1';
      });

      clearTimeout(tip._hideTimeout);
      tip._hideTimeout = setTimeout(() => {
        tip.style.opacity = '0';
        setTimeout(() => { tip.style.display = 'none'; }, 250);
      }, 900);
    };

    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(textToCopy).then(() => {
        showCopyTooltip(btn);
      }).catch(() => {
        fallbackCopy(textToCopy, btn, () => { showCopyTooltip(btn); });
      });
    } else {
      fallbackCopy(textToCopy, btn, () => { showCopyTooltip(btn); });
    }
  });

  function fallbackCopy(text, btn, restore) {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.select();
    try {
      document.execCommand('copy');
      if (typeof restore === 'function') restore();
      // ensure tooltip shows if provided as restore
      try { showCopyTooltip(btn); } catch (e) { /* ignore */ }
    } catch (err) {
      // last resort: prompt
      window.prompt('Скопируйте текст вручную:', text);
    }
    ta.remove();
  }
</script>

<style is:global>
  .feature-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .feature-header h3 {
    flex: 1 1 auto;
  }

  .copy-feature-btn {
    position: relative;
    padding: 0.75rem 1rem;
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 0.5rem;
    color: var(--text);
    cursor: pointer;
    display: flex;
    align-items: center;
  }

  .copy-feature-btn:active {
    transform: translateY(1px);
  }

  .copy-tooltip {
    position: fixed;
    background: var(--primary);
    color: white;
    padding: 0.35rem 0.6rem;
    border-radius: 6px;
    font-size: 0.9rem;
    box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    transition: opacity 180ms ease;
    z-index: 20000;
    display: none;
    opacity: 0;
    pointer-events: none;
  }
  
  .content {
    max-width: 1200px;
    margin: 0 auto;
  }

  .back-link {
    display: inline-block;
    margin-bottom: 2rem;
    color: var(--primary);
    text-decoration: none;
  }

  .back-link:hover {
    text-decoration: underline;
  }

  .class-header {
    margin-bottom: 2rem;
  }

  .name-en {
    color: var(--text);
    opacity: 0.7;
    font-size: 0.8em;
  }

  .source {
    color: var(--text);
    opacity: 0.8;
  }

  .class-description {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .subclass-selector {
    margin-bottom: 1.5rem;
  }

  .subclass-selector select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    border-radius: 0.25rem;
    background: var(--background);
    color: var(--text);
    font-size: 1rem;
  }

  .lore-content {
    line-height: 1.6;
    margin: 1rem 0;
  }

  .lore-content p {
    margin-bottom: 1rem;
  }

  .lore-content p:last-child {
    margin-bottom: 0;
  }

  .base-lore {
    margin-top: 1.5rem;
    padding: 1rem;
    background: var(--background);
    border-radius: 0.25rem;
  }

  .base-lore summary {
    cursor: pointer;
    color: var(--primary);
  }

  .class-basics {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .basic-info,
  .proficiencies,
  .multiclass-info {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .equipment {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .equipment-choice {
    margin-top: 1.5rem;
  }

  .equipment-choice h3 {
    color: var(--primary);
    margin-bottom: 0.5rem;
  }

  .equipment-choice ul {
    list-style-type: disc;
    margin-left: 1.5rem;
  }

  .equipment-choice li {
    margin-bottom: 0.5rem;
  }

  dl {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.5rem 1rem;
    margin-top: 1rem;
  }

  dt {
    font-weight: 600;
    color: var(--primary);
  }

  .feature {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .feature-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }

  .feature-header h3 {
    color: var(--primary);
    margin: 0;
    font-size: 1.25rem;
  }

  .feature-level {
    font-size: 0.875rem;
    color: var(--text);
    opacity: 0.8;
    padding: 0.25rem 0.5rem;
    background: var(--background);
    border-radius: 0.25rem;
  }

  .feature-description p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }

  .feature-description p:last-child {
    margin-bottom: 0;
  }

  .collapsible-content {
    margin-top: 1rem;
    border-top: 1px solid var(--card-border);
    padding-top: 1rem;
  }

  .collapsible-item {
    background: var(--background);
    border-radius: 0.5rem;
    margin: 0.5rem 0;
    overflow: hidden;
  }

  .collapsible-item:last-child {
    margin-bottom: 0;
  }

  .collapsible-item summary {
    padding: 0.75rem 1rem;
    cursor: pointer;
    font-weight: 500;
    user-select: none;
  }

  .collapsible-item summary:hover {
    background: var(--nav-hover-bg);
  }

  .collapsible-description {
    padding: 1rem;
    border-top: 1px solid var(--card-border);
    background: var(--card-bg);
  }

  .collapsible-description p {
    margin-bottom: 0.75rem;
    line-height: 1.6;
  }

  .collapsible-description p:last-child {
    margin-bottom: 0;
  }

  .spell-table {
    width: 100%;
    margin: 1rem 0;
    border-collapse: collapse;
    background: var(--card-bg);
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: var(--card-shadow);
  }

  .spell-table th,
  .spell-table td {
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    text-align: left;
  }

  .spell-table th {
    background: var(--background);
    font-weight: 600;
    color: var(--primary);
  }

  .spell-table tbody tr:nth-child(even) {
    background: transparent;
  }

  .spell-table tbody tr {
    background: transparent !important;
  }

  .spell-table tbody tr:hover {
    background: var(--nav-hover-bg);
  }

  .spell-table th:first-child {
    border-top-left-radius: 0.5rem;
  }

  .spell-table th:last-child {
    border-top-right-radius: 0.5rem;
  }

  .spell-table tbody tr:last-child td:first-child {
    border-bottom-left-radius: 0.5rem;
  }

  .spell-table tbody tr:last-child td:last-child {
    border-bottom-right-radius: 0.5rem;
  }

  .subclass-feature {
    background: var(--subclass-feature-bg);
    border-color: var(--subclass-feature-border);
  }

  .subclass-feature .feature-header h3 {
    color: var(--subclass-feature-title);
  }

  .subclass-feature .feature-level {
    background: var(--subclass-feature-border);
    color: white;
  }

  .subclass-feature .collapsible-item {
    background: var(--subclass-feature-border);
  }

  .subclass-feature .collapsible-description {
    background: var(--subclass-feature-bg);
  }

  /* Table styling for class abilities */
  .feature-description table,
  .collapsible-description table {
    width: 100%;
    margin: 1rem 0;
    border-collapse: collapse;
    background: var(--card-bg);
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border: 1px solid var(--card-border);
  }

  .feature-description table th,
  .feature-description table td,
  .collapsible-description table th,
  .collapsible-description table td {
    padding: 0.75rem;
    border: 1px solid var(--card-border);
    text-align: left;
    vertical-align: top;
  }

  .feature-description table th,
  .collapsible-description table th {
    background: var(--primary);
    color: white;
    font-weight: 600;
    font-size: 0.95rem;
  }

  .feature-description table tbody tr,
  .collapsible-description table tbody tr {
    transition: background-color 0.2s ease;
  }

  .feature-description table tbody tr,
  .collapsible-description table tbody tr {
    background: transparent !important;
  }

  .feature-description table tbody tr:nth-child(even),
  .collapsible-description table tbody tr:nth-child(even) {
    background: transparent;
  }

  .feature-description table tbody tr:hover,
  .collapsible-description table tbody tr:hover {
    background: var(--nav-hover-bg);
  }

  .feature-description table th:first-child,
  .collapsible-description table th:first-child {
    border-top-left-radius: 0.5rem;
  }

  .feature-description table th:last-child,
  .collapsible-description table th:last-child {
    border-top-right-radius: 0.5rem;
  }

  .feature-description table tbody tr:last-child td:first-child,
  .collapsible-description table tbody tr:last-child td:first-child {
    border-bottom-left-radius: 0.5rem;
  }

  .feature-description table tbody tr:last-child td:last-child,
  .collapsible-description table tbody tr:last-child td:last-child {
    border-bottom-right-radius: 0.5rem;
  }

  /* Special styling for subclass feature tables */
  .subclass-feature .feature-description table th,
  .subclass-feature .collapsible-description table th {
    background: var(--subclass-feature-title);
    color: white;
  }

  .subclass-feature .feature-description table,
  .subclass-feature .collapsible-description table {
    background: var(--subclass-feature-bg);
    border-color: var(--subclass-feature-border);
  }

  .subclass-feature .feature-description table tbody tr:nth-child(even),
  .subclass-feature .collapsible-description table tbody tr:nth-child(even) {
    background: transparent;
    opacity: 1;
  }

  .subclass-feature .feature-description table tbody tr,
  .subclass-feature .collapsible-description table tbody tr {
    background: transparent !important;
    opacity: 1;
  }

  /* Scroll to top button */
  .scroll-to-top {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    width: 3rem;
    height: 3rem;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transition: all 0.3s ease;
    opacity: 0;
    visibility: hidden;
    transform: translateY(20px);
    z-index: 100;
  }

  .scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }

  .scroll-to-top:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  }

  .scroll-to-top:active {
    transform: translateY(0);
  }

  /* Responsive table design */
  @media (max-width: 768px) {
    .feature-description table,
    .collapsible-description table {
      font-size: 0.9rem;
    }
    
    .feature-description table th,
    .feature-description table td,
    .collapsible-description table th,
    .collapsible-description table td {
      padding: 0.5rem;
    }
  }
</style>