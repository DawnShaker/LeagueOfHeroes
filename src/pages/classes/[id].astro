---
import Layout from '../../layouts/Layout.astro';
import ClassTable from '../../components/classes/ClassTable.astro';
import { classes } from '../../data/classes';

export function getStaticPaths() {
return classes.map(classData => ({
params: { id: classData.id },
props: { classData }
}));
}

const { classData } = Astro.props;

// Функция для преобразования текстовой таблицы в структурированные данные
function parseTableData(text: string) {
const rows = text.split('\n').filter(row => row.trim());
return rows.map(row => {
const [level, spells] = row.split('\t');
return { level, spells };
});
}
---

<Layout title={`${classData.name}`}>
  <div class="content">
    <a href="/classes" class="back-link">← Назад к классам</a>

    <div class="class-header">
      <h1>{classData.name} <span class="name-en">[{classData.nameEn}]</span></h1>
      <div class="source">{classData.sourceBook}</div>
    </div>

    <div class="class-description">
      <div class="subclass-selector">
        <select id="subclass-select">
          <option value="">Выберите подкласс</option>
          {classData.subclasses.map(subclass => (
          <option value={subclass.id}>{subclass.name} [{subclass.nameEn}]</option>
          ))}
        </select>
      </div>

      <div id="class-lore" class="lore-content">
        <p>{classData.description}</p>
      </div>

      <details id="base-lore" class="base-lore" style="display: none;">
        <summary>Основное описание класса</summary>
        <p>{classData.description}</p>
      </details>
    </div>

    <div class="class-basics">
      <div class="basic-info">
        <h2>Основные характеристики</h2>
        <dl>
          <dt>Основная характеристика</dt>
          <dd>{classData.primaryAbility}</dd>

          <dt>Кость хитов</dt>
          <dd>к{classData.hitDice}</dd>

          <dt>Хиты на 1 уровне</dt>
          <dd>{classData.hitPoints.level1}</dd>

          <dt>Хиты на следующих уровнях</dt>
          <dd>{classData.hitPoints.higherLevels}</dd>
        </dl>
      </div>

      <div class="proficiencies">
        <h2>Владения</h2>
        <dl>
          <dt>Доспехи</dt>
          <dd>{classData.proficiencies?.armor?.join(', ') || 'Нет'}</dd>

          <dt>Оружие</dt>
          <dd>{classData.proficiencies?.weapons?.join(', ') || 'Нет'}</dd>

          <dt>Спасброски</dt>
          <dd>{classData.proficiencies?.savingThrows?.join(', ') || 'Нет'}</dd>

          <dt>Навыки</dt>
          <dd>Выберите {classData.proficiencies.skills.count} из: {classData.proficiencies?.skills?.list?.join(', ') || 'Нет'}</dd>

          <dt>Инструменты</dt>
          <dd>{classData.proficiencies?.tools?.join(', ') || 'Нет'}</dd>
        </dl>
      </div>
    </div>

    <div class="equipment">
      <h2>Стартовое снаряжение</h2>
      <p>Выберите один из следующих наборов:</p>

      {classData.equipment.default.map(choice => (
      <div class="equipment-choice">
        <h3>Вариант {choice.choice}</h3>
        <ul>
          {choice.items.map(item => (
          <li>{item}</li>
          ))}
        </ul>
      </div>
      ))}
    </div>

    <div class="class-progression">
      <h2>Развитие класса</h2>
      <ClassTable levels={classData.levels} />
    </div>

    <div id="features-container" class="class-features">
      <h2>Умения класса</h2>
      {classData.features.map(feature => (
      <div class="feature">
        <div class="feature-header">
          <h3>{feature.name}</h3>
          <span class="feature-level">{feature.level} уровень</span>
        </div>
        <div class="feature-description">
          {feature.description.split('\n').map(paragraph => (
            <p>{paragraph}</p>
          ))}
          
          {feature.collapsible && (
            <div class="collapsible-content">
              {feature.collapsible.map(item => (
                <details class="collapsible-item">
                  <summary>{item.title}</summary>
                  <div class="collapsible-description">
                    {item.description.split('\n').map(paragraph => (
                      <p>{paragraph}</p>
                    ))}
                  </div>
                </details>
              ))}
            </div>
          )}
        </div>
      </div>
      ))}
    </div>

    <!-- Template для создания элементов способностей -->
    <template id="feature-template">
      <div class="feature">
        <div class="feature-header">
          <h3></h3>
          <span class="feature-level"></span>
        </div>
        <div class="feature-description"></div>
      </div>
    </template>

    <!-- Scroll to top button -->
    <button id="scroll-to-top" class="scroll-to-top" aria-label="Прокрутить наверх">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="m18 15-6-6-6 6"/>
      </svg>
    </button>
  </div>
</Layout>

<script define:vars={{ classData }}>
  document.addEventListener('DOMContentLoaded', () => {
    const subclassSelect = document.getElementById('subclass-select');
    const classLore = document.getElementById('class-lore');
    const baseLore = document.getElementById('base-lore');
    const featuresContainer = document.getElementById('features-container');
    const featureTemplate = document.getElementById('feature-template');
    let currentSubclass = null;

    function createTableElement(tableText) {
      const rows = tableText.split('\n').filter(row => row.trim());
      const table = document.createElement('table');
      table.className = 'spell-table';

      // Check if this is a header-data table format
      const hasHeaders = rows.length > 1 && (
        rows[0].includes('\t') || 
        rows[0].split(/\s{2,}/).length > 1
      );

      if (hasHeaders) {
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        const headers = rows[0].includes('\t') 
          ? rows[0].split('\t') 
          : rows[0].split(/\s{2,}/);
        
        headers.forEach(header => {
          const th = document.createElement('th');
          th.textContent = header.trim();
          headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');
        rows.slice(1).forEach(row => {
          const tr = document.createElement('tr');
          const cells = row.includes('\t') 
            ? row.split('\t') 
            : row.split(/\s{2,}/);
          
          cells.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell.trim();
            tr.appendChild(td);
          });
          
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      } else {
        // Fallback for simple row-based tables
        const tbody = document.createElement('tbody');
        rows.forEach(row => {
          const tr = document.createElement('tr');
          const cells = row.includes('\t') 
            ? row.split('\t') 
            : row.split(/\s{2,}/);
          
          cells.forEach(cell => {
            const td = document.createElement('td');
            td.textContent = cell.trim();
            tr.appendChild(td);
          });
          
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      }

      return table;
    }

    function createFeatureElement(feature, isSubclassFeature = false) {
      const template = featureTemplate.content.cloneNode(true);
      const featureElement = template.querySelector('.feature');
      
      if (isSubclassFeature) {
        featureElement.classList.add('subclass-feature');
      }
      
      featureElement.querySelector('h3').textContent = feature.name;
      featureElement.querySelector('.feature-level').textContent = `${feature.level} уровень`;
      
      const descriptionContainer = featureElement.querySelector('.feature-description');
      
      if (feature.collapsible) {
        const collapsibleContent = document.createElement('div');
        collapsibleContent.className = 'collapsible-content';
        
        feature.collapsible.forEach(item => {
          const details = document.createElement('details');
          details.className = 'collapsible-item';
          
          const summary = document.createElement('summary');
          summary.textContent = item.title;
          details.appendChild(summary);
          
          const description = document.createElement('div');
          description.className = 'collapsible-description';
          
          if (item.tableData) {
            // Create table from structured data
            const table = document.createElement('table');
            table.className = 'spell-table';
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            item.tableData.headers.forEach(header => {
              const th = document.createElement('th');
              th.textContent = header;
              headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body
            const tbody = document.createElement('tbody');
            item.tableData.rows.forEach(row => {
              const tr = document.createElement('tr');
              row.forEach(cell => {
                const td = document.createElement('td');
                td.textContent = cell;
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            
            description.appendChild(table);
          } else {
            // Regular text content
            item.description.split('\n').forEach(paragraph => {
              const p = document.createElement('p');
              p.textContent = paragraph;
              description.appendChild(p);
            });
          }
          
          details.appendChild(description);
          collapsibleContent.appendChild(details);
        });
        
        descriptionContainer.appendChild(collapsibleContent);
      } else if (feature.name.toLowerCase().includes('таблица')) {
        const table = createTableElement(feature.description);
        descriptionContainer.appendChild(table);
      } else {
        feature.description.split('\n').forEach(paragraph => {
          const p = document.createElement('p');
          p.textContent = paragraph;
          descriptionContainer.appendChild(p);
        });
      }

      return featureElement;
    }

    function updateFeatures(subclassId) {
      if (!featuresContainer || !featureTemplate) return;

      let features = [...classData.features];
      if (subclassId) {
        const subclass = classData.subclasses.find(s => s.id === subclassId);
        if (subclass) {
          // Get all levels where subclass has features
          const subclassLevels = new Set(subclass.features.map(f => f.level));
          
          // Filter out base class features that are replaced by subclass features
          features = features.filter(f => {
            // Keep feature if level doesn't have subclass features
            if (!subclassLevels.has(f.level)) return true;
            
            // Remove the subclass selection feature
            if (f.name.includes('Подкласс') || f.name.includes('Круг') || 
                f.name.includes('Домен') || f.name.includes('Путь')) {
              return false;
            }
            
            return true;
          });
          
          // Add subclass features
          features = [...features, ...subclass.features];
        }
      }

      features.sort((a, b) => a.level - b.level);

      const title = featuresContainer.querySelector('h2');
      featuresContainer.innerHTML = '';
      featuresContainer.appendChild(title);

      features.forEach(feature => {
        const isSubclassFeature = subclassId && classData.subclasses
          .find(s => s.id === subclassId)?.features
          .some(f => f.name === feature.name);
        const featureElement = createFeatureElement(feature, isSubclassFeature);
        featuresContainer.appendChild(featureElement);
      });
    }

    subclassSelect?.addEventListener('change', (e) => {
      const subclassId = e.target.value;
      const subclass = classData.subclasses.find(s => s.id === subclassId);
      
      // Save subclass selection to localStorage
      if (subclassId) {
        localStorage.setItem(`class-${classData.id}-subclass`, subclassId);
      } else {
        localStorage.removeItem(`class-${classData.id}-subclass`);
      }

      // Update URL with subclass selection
      const newUrl = subclassId 
        ? `/classes/${classData.id}?subclass=${subclassId}`
        : `/classes/${classData.id}`;
      window.history.pushState({ subclassId }, '', newUrl);
      if (classLore && baseLore) {
        if (subclass) {
          classLore.innerHTML = subclass.description.split('\n').map(paragraph =>
            `<p>${paragraph}</p>`
          ).join('');
          baseLore.style.display = 'block';
        } else {
          classLore.innerHTML = classData.description.split('\n').map(paragraph =>
            `<p>${paragraph}</p>`
          ).join('');
          baseLore.style.display = 'none';
        }
      }

      updateFeatures(subclassId);
    });
    
    // Load saved subclass selection on page load
    function loadSavedSubclass() {
      // Check URL parameters first, then localStorage
      const urlParams = new URLSearchParams(window.location.search);
      const urlSubclass = urlParams.get('subclass');
      const savedSubclass = urlSubclass || localStorage.getItem(`class-${classData.id}-subclass`);
      
      if (savedSubclass && subclassSelect) {
        subclassSelect.value = savedSubclass;
        // Trigger change event to update the display
        subclassSelect.dispatchEvent(new Event('change'));
      }
    }
    
    // Handle browser back/forward buttons
    window.addEventListener('popstate', (event) => {
      const urlParams = new URLSearchParams(window.location.search);
      const subclassId = urlParams.get('subclass') || '';
      
      if (subclassSelect) {
        subclassSelect.value = subclassId;
        // Trigger change event to update the display
        subclassSelect.dispatchEvent(new Event('change'));
      }
    });
    
    // Save scroll position periodically and on page unload
    function saveScrollPosition() {
      localStorage.setItem(`class-${classData.id}-scroll`, window.scrollY.toString());
    }
    
    // Load saved scroll position
    function loadScrollPosition() {
      const savedScroll = localStorage.getItem(`class-${classData.id}-scroll`);
      if (savedScroll) {
        // Use setTimeout to ensure DOM is fully rendered
        setTimeout(() => {
          window.scrollTo(0, parseInt(savedScroll));
        }, 100);
      }
    }
    
    // Save scroll position on scroll (throttled)
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(saveScrollPosition, 150);
    });
    
    // Save scroll position before page unload
    window.addEventListener('beforeunload', saveScrollPosition);
    
    // Initialize saved states
    loadSavedSubclass();
    loadScrollPosition();
    
    // Scroll to top button functionality
    const scrollToTopButton = document.getElementById('scroll-to-top');
    
    function toggleScrollButton() {
      if (scrollToTopButton) {
        if (window.scrollY > 300) {
          scrollToTopButton.classList.add('visible');
        } else {
          scrollToTopButton.classList.remove('visible');
        }
      }
    }
    
    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    
    // Show/hide button based on scroll position
    window.addEventListener('scroll', toggleScrollButton);
    
    // Scroll to top when button is clicked
    scrollToTopButton?.addEventListener('click', scrollToTop);
    
    // Initial check for button visibility
    toggleScrollButton();
  });
</script>

<style>
  .content {
    max-width: 1200px;
    margin: 0 auto;
  }

  .back-link {
    display: inline-block;
    margin-bottom: 2rem;
    color: var(--primary);
    text-decoration: none;
  }

  .back-link:hover {
    text-decoration: underline;
  }

  .class-header {
    margin-bottom: 2rem;
  }

  .name-en {
    color: var(--text);
    opacity: 0.7;
    font-size: 0.8em;
  }

  .source {
    color: var(--text);
    opacity: 0.8;
  }

  .class-description {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .subclass-selector {
    margin-bottom: 1.5rem;
  }

  .subclass-selector select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    border-radius: 0.25rem;
    background: var(--background);
    color: var(--text);
    font-size: 1rem;
  }

  .lore-content {
    line-height: 1.6;
    margin: 1rem 0;
  }

  .lore-content p {
    margin-bottom: 1rem;
  }

  .lore-content p:last-child {
    margin-bottom: 0;
  }

  .base-lore {
    margin-top: 1.5rem;
    padding: 1rem;
    background: var(--background);
    border-radius: 0.25rem;
  }

  .base-lore summary {
    cursor: pointer;
    color: var(--primary);
  }

  .class-basics {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .basic-info,
  .proficiencies {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .equipment {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .equipment-choice {
    margin-top: 1.5rem;
  }

  .equipment-choice h3 {
    color: var(--primary);
    margin-bottom: 0.5rem;
  }

  .equipment-choice ul {
    list-style-type: disc;
    margin-left: 1.5rem;
  }

  .equipment-choice li {
    margin-bottom: 0.5rem;
  }

  dl {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.5rem 1rem;
    margin-top: 1rem;
  }

  dt {
    font-weight: 600;
    color: var(--primary);
  }

  .feature {
    background: var(--card-bg);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    box-shadow: var(--card-shadow);
    border: 1px solid var(--card-border);
  }

  .feature-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }

  .feature-header h3 {
    color: var(--primary);
    margin: 0;
    font-size: 1.25rem;
  }

  .feature-level {
    font-size: 0.875rem;
    color: var(--text);
    opacity: 0.8;
    padding: 0.25rem 0.5rem;
    background: var(--background);
    border-radius: 0.25rem;
  }

  .feature-description p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }

  .feature-description p:last-child {
    margin-bottom: 0;
  }

  .collapsible-content {
    margin-top: 1rem;
    border-top: 1px solid var(--card-border);
    padding-top: 1rem;
  }

  .collapsible-item {
    background: var(--background);
    border-radius: 0.5rem;
    margin: 0.5rem 0;
    overflow: hidden;
  }

  .collapsible-item:last-child {
    margin-bottom: 0;
  }

  .collapsible-item summary {
    padding: 0.75rem 1rem;
    cursor: pointer;
    font-weight: 500;
    user-select: none;
  }

  .collapsible-item summary:hover {
    background: var(--nav-hover-bg);
  }

  .collapsible-description {
    padding: 1rem;
    border-top: 1px solid var(--card-border);
    background: var(--card-bg);
  }

  .collapsible-description p {
    margin-bottom: 0.75rem;
    line-height: 1.6;
  }

  .collapsible-description p:last-child {
    margin-bottom: 0;
  }

  .spell-table {
    width: 100%;
    margin: 1rem 0;
    border-collapse: collapse;
    background: var(--card-bg);
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: var(--card-shadow);
  }

  .spell-table th,
  .spell-table td {
    padding: 0.5rem;
    border: 1px solid var(--card-border);
    text-align: left;
  }

  .spell-table th {
    background: var(--background);
    font-weight: 600;
    color: var(--primary);
  }

  .spell-table tbody tr:nth-child(even) {
    background: var(--background);
  }

  .spell-table tbody tr:hover {
    background: var(--nav-hover-bg);
  }

  .spell-table th:first-child {
    border-top-left-radius: 0.5rem;
  }

  .spell-table th:last-child {
    border-top-right-radius: 0.5rem;
  }

  .spell-table tbody tr:last-child td:first-child {
    border-bottom-left-radius: 0.5rem;
  }

  .spell-table tbody tr:last-child td:last-child {
    border-bottom-right-radius: 0.5rem;
  }

  .subclass-feature {
    background: var(--subclass-feature-bg);
    border-color: var(--subclass-feature-border);
  }

  .subclass-feature .feature-header h3 {
    color: var(--subclass-feature-title);
  }

  .subclass-feature .feature-level {
    background: var(--subclass-feature-border);
    color: white;
  }

  .subclass-feature .collapsible-item {
    background: var(--subclass-feature-border);
  }

  .subclass-feature .collapsible-description {
    background: var(--subclass-feature-bg);
  }

  /* Table styling for class abilities */
  .feature-description table,
  .collapsible-description table {
    width: 100%;
    margin: 1rem 0;
    border-collapse: collapse;
    background: var(--card-bg);
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    border: 1px solid var(--card-border);
  }

  .feature-description table th,
  .feature-description table td,
  .collapsible-description table th,
  .collapsible-description table td {
    padding: 0.75rem;
    border: 1px solid var(--card-border);
    text-align: left;
    vertical-align: top;
  }

  .feature-description table th,
  .collapsible-description table th {
    background: var(--primary);
    color: white;
    font-weight: 600;
    font-size: 0.95rem;
  }

  .feature-description table tbody tr,
  .collapsible-description table tbody tr {
    transition: background-color 0.2s ease;
  }

  .feature-description table tbody tr:nth-child(even),
  .collapsible-description table tbody tr:nth-child(even) {
    background: var(--background);
  }

  .feature-description table tbody tr:hover,
  .collapsible-description table tbody tr:hover {
    background: var(--nav-hover-bg);
  }

  .feature-description table th:first-child,
  .collapsible-description table th:first-child {
    border-top-left-radius: 0.5rem;
  }

  .feature-description table th:last-child,
  .collapsible-description table th:last-child {
    border-top-right-radius: 0.5rem;
  }

  .feature-description table tbody tr:last-child td:first-child,
  .collapsible-description table tbody tr:last-child td:first-child {
    border-bottom-left-radius: 0.5rem;
  }

  .feature-description table tbody tr:last-child td:last-child,
  .collapsible-description table tbody tr:last-child td:last-child {
    border-bottom-right-radius: 0.5rem;
  }

  /* Special styling for subclass feature tables */
  .subclass-feature .feature-description table th,
  .subclass-feature .collapsible-description table th {
    background: var(--subclass-feature-title);
    color: white;
  }

  .subclass-feature .feature-description table,
  .subclass-feature .collapsible-description table {
    background: var(--subclass-feature-bg);
    border-color: var(--subclass-feature-border);
  }

  .subclass-feature .feature-description table tbody tr:nth-child(even),
  .subclass-feature .collapsible-description table tbody tr:nth-child(even) {
    background: var(--subclass-feature-border);
    opacity: 0.3;
  }

  /* Scroll to top button */
  .scroll-to-top {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    width: 3rem;
    height: 3rem;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transition: all 0.3s ease;
    opacity: 0;
    visibility: hidden;
    transform: translateY(20px);
    z-index: 100;
  }

  .scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }

  .scroll-to-top:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  }

  .scroll-to-top:active {
    transform: translateY(0);
  }

  /* Responsive table design */
  @media (max-width: 768px) {
    .feature-description table,
    .collapsible-description table {
      font-size: 0.9rem;
    }
    
    .feature-description table th,
    .feature-description table td,
    .collapsible-description table th,
    .collapsible-description table td {
      padding: 0.5rem;
    }
  }
</style>